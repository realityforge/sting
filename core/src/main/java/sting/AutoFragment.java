package sting;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import javax.annotation.Nonnull;

/**
 * Identify an interface that generates a fragment from a list of contributors.
 * The use of this annotation comes with significant constraints. The contributors are
 * identified as types annotated by {@link ContributeTo} where the {@link ContributeTo#value()}
 * parameter is exactly the as the {@link AutoFragment#value()} parameter.
 *
 * <p>The following constraints exist:</p>
 *
 * <ul>
 * <li>
 *   The {@link AutoFragment} annotated type and the {@link ContributeTo} annotated types must be
 *   compiled using in a single javac invocation. If the linked AutoFragment and ContributedTo
 *   are compiled using different javac invocations then they will not find each other and will generate
 *   an error.
 * </li>
 * <li>
 *   If there are multiple {@link AutoFragment} annotated types that specify the same value for the
 *   {@link AutoFragment#value()} parameter and they are compiled using a single javac invocation then
 *   the annotation processor will generate an error.
 * </li>
 * <li>
 *   If the {@link ContributeTo} annotated type is generated by an annotation
 *   processor then it MUST NOT be generated in a round after the {@link AutoFragment} has generated
 *   the fragment. The annotation processor will generate the fragment for the {@link AutoFragment} type
 *   after a round where there is at least 1 contributor and no contributors have been added in the current
 *   round.
 * </li>
 * </ul>
 */
@Documented
@Retention( RetentionPolicy.RUNTIME )
@Target( ElementType.TYPE )
@StingProvider( "[FlatEnclosingName]Sting_[SimpleName]_Fragment" )
public @interface AutoFragment
{
  /**
   * An opaque string that identifies auto-fragment.
   *
   * @return the auto-fragment key.
   */
  @Nonnull
  String value();
}
